#include <iostream>
using std::cout;
using std::cin;
//排列与组合基础
//1.　从n个不同元素中，任取m个元素并成一个集合，叫做从n个不同元素中取出m个元素的一个组合。
//    其中，当 m == n 时，称为全组合.
//
//2.　从n个不同元素中，任取m个元素按照一定的顺序排成一个集合，叫做从n个不同元素中取出m个元素的一个排列。
//    其中，当 m == n 时，称为全排列.
//由此可见，排列的约束要比组合更加严格
//
//排列公式：
//　　　　eg: A(6,4) = 6!/(6-4)!=(6x5x4x3x2x1)/(2*1)=360。
//    计算思想解释:<有顺序,均概率> 
//                  第一个位置谁都有可能被选到 
//                  所以首先从6个元素中任选1个，概率为 1/6, 共有6种可能性.
//                  第二个位置剩下的5个元素都有可能被选到
//                  从剩下的5个元素中任选1个，概率为 1/5, 共有5种可能性.
//                  ...
//                  但如果我们只选其中前面的 k 个数进行排列, 只需要填够想要的位置， 多余的元素不进行排列即可.
//                  比如 A(6,4) = 6*5*4*3 可以数学变化为 --> =(6x5x4x3x2x1)/(2*1)
//组合公式:<无顺序>
//　　　　eg: C(6,4) = A(6,4)/4! = 15。
//    计算思想解释: 在排列中, 
//                  有可能第一次选元素 a, 第二次选元素 b
//                  也有可能第一次选元素 b, 第二次选元素 a
//                  我们算作两种可能性，但在组合中 ab、ba 算作一种可能性. 所以排列算重了，我们仅仅需要去掉算重的部分.
//                  //这里我还是真的不会解释
//                  所以我们计算组合只需要用相应参数的 排列公式/参选个数
//                  即 eg: C(6,4) = A(6,4)/4! = 15。


//状态转移方程:
//n=3, k = 2
//2/3 * 1/3
//f(n,k) = f(n-1,k)
int n_choose_k(int n, int k)
{
    if(n < k)
    {
        return 0;
    }
    else if(k == 0 || k == n)
    {
        return 1;
    }
    else if(k < 0 || n < 0){
      return -1; 
    }
    return n_choose_k(n-1,k);
}

int main()
{
    int n = 8;
    int k = 7;
    n_choose_k(n, k);
    return 0;
}
