# ProjectI
> 从这里开始，才真正的感受到了 cs61c 所还有的难度.

# TaskI-C
## 目的
1. 数字识别(通过欧几里得距离)
2. 矩阵稀疏化(见 稀疏表示)


讲述了:
1. 二维数组转换一维数组，bmp文件，矩阵
2. 数字识别： 
> 数字用一个矩阵表示，用坐标和欧几里得公式来计算 欧氏距离

 由于这个矩阵可以被旋转，翻转(横向翻转、纵向翻转), 变形. 所以如果我有4个比较后的欧几里得距离，那么"digit distance" 将会是 min(num1, num2, num3, num4)

3. 稀疏表示
 我们只存储 non-white 像素，其余未存储的部分都是白色像素。虽然我们会用额外的空间来表示表示更多具体细节. 但只要 white pixel:non-white pixel 足够的少，依然可以节省空间. (这里引出稀疏矩阵)
 **坑爹之处**: 大多数 spare matrices 省略0s(即表示颜色的 RGB 值), 但在这里我们省略 255s.
ps: 这里打断的英文背景与概述读的我恶心，最终还是整页翻译了过来.

  题目要求: 给你一个经过 翻转、旋转、变形后的数字(矩阵表示), 让你识别它是什么数字.
  技巧:  通过 *所给的矩阵* 轮番与0-9共10个标准的template数字作比较，且计算 欧几里得距离.  其中算的结果最小的为识别出来的数字.
  特别注意: 所测试的图像可能大于template图像

# Task二-Mips
## 目的
1. 3n+1 猜想
2. 稀疏到密集矩阵并打印密集功能。



